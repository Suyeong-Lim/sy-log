---
title: Algorithm - 프린터
date: 2022-07-10
tags: ["algorithm", "level2"]
description: 프로그래머스 알고리즘 문제
---

프로그래머스 level2. [[스택 / 큐]] 프린터

[프린터 문제링크](https://programmers.co.kr/learn/courses/30/lessons/42587)

### 문제 설명

일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.

```
1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
3. 그렇지 않으면 J를 인쇄합니다.
```

예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.

내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.

현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.
- 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.
- location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.

### 입출력 예

### 분류

- 스택 / 큐

# 2. 풀이

> Queue 를 구현해서 푸는 방법을 알아보자. 값과 인덱스가 필요하므로 자료구조를 묶어줄 필요가 있다. 그 후 우선순위에 따라 enqueue와 dequeue 를 진행하면서, dequeue시에
> 찾아야하는 값 (location) 인지 아닌지 검사한다. location 값이 아니라면 다음 값을 검사한다.

문제를 풀려면 다음과 같은 조건이 필요하다.

- 큐 구현
- 정렬된 priorities : 주어진 priorities 값과 동시에 어떤 순서로 출력될 것인지 알아내야 하기 때문에 오름차순으로 정렬된 prioritries 가 필요하다. 예를 들면 [2,1,3,2] 는 [3,2,2,1] 의 순서로 출력될 것이다.

큐란?
큐는 `FIFO` 로 동작하는 자료구조로 가장 먼저 들어온 데이터가 가장 먼저 나가는 자료 구조이다. 가장 처음의 원소를 front, 가장 마지막의 원소를 rear 로 지칭하며 큐에 값을 삽입하는 `enqueue` 시에 rear 의 위치는 기존위치의 +1로 , 값을 삭제하는 `dequeue` 시에는 front 가 기존 위치의 +1로 이동한다.

그럼 큐를 구현해보자.
(자바스크립트에서 배열의 shift 메서드로도 문제를 풀 수있지만 큐를 구현하여 푸는 것 보다 연산이 더 필요하고 그에따른 시간복잡도가 높다. 큐를 구현하면 O(1)로 해결이 가능하다. )

```js
class Queue {

constructor() {
this.queue = [];
this.front = 0;
this.rear = 0;
}}

enqueue(value){ //원소를 맨 뒤에 추가한다. rear값(위치)늘려서 추가.
this.queue[this.rear++]= value
}

dequeue(){ //맨 앞의 값을 리턴.삭제한다.
const value = this.queue[this.front];
delete this.queue[this.front];
this.front += 1; //front 는 이전 front 의 뒤의 값이 된다.
return value;

peek(){ //큐의 첫번째 값을 리턴한다.
return this.queue[this.front]
}

size(){ //큐의 사이즈를 리턴한다.
return this.rear-this.front;
}
```

구현된 큐를 이용해서 문제를 풀어보자.
문제에서 요구하는 과정은 다음과 같다.

> 1.  대기 목록에서 가장 앞에 있는 문서(J) 를 꺼낸다.
> 2.  나머지 대기 목록에서 중요도가 (J) 보다 높은 문서가 있으면, J를 가장 마지막에 넣는다.
> 3.  그렇지 않으면 J를 인쇄한다.
> 4.  1~3 이 반복될 때 location 값으로 주어진 인덱스의 문서가 몇 번째로 인쇄되는지 리턴하라.

먼저 구현한 큐 클래스로 큐를 생성한 후 값을 넣어줍니다.

```js
function solution(priorities, location) {
  let answer = 0;
  const queue = new Queue(); //큐 생성

  //1. 큐에 priorities 를 인덱스와 함께 넣어준다.
  for (let i = 0; i < priorities.length; i++) {
    queue.enqueue([priorities[i], i]);
  }

  // queue = [[2,0],[1,1],[3,2],[2,3]]
}
```

그 후 대기 목록 가장 앞에 있는 문서를 꺼내고 maxPriority(중요도) 를 비교해서
중요도 보다 작으면 다시 큐에 넣고, 크면 프린트합니다.

```JS
function solution(priorities,location){

...
priorities.sort((a,b)=>b-a);
const currentValue = queue.peek(); //꺼내기

if(currentValue[1] < priorities[count]){
const front = queue.dequeue();
queue.enqueue(front)
}else{
const printedValue = queue.dequeue();
}
}
```

이때 중요도 `priorities` 를 내림차순으로 정렬해주는 것이 추후 dequeue 하며 location 을 비교하는데 필요합니다. 프린터는 정렬된 priorities 순으로 인쇄되며 그 순서를 location 과 비교하며 answer를 count 해주어야 하기 때문입니다.

3 에서 만약 중요도가 가장 높은 문서라면 인쇄 한다고 하였습니다. 위에서 dequeue 를 해주었는데,
dequeue 시에 location 으로 주어진 값, 즉 우리가 찾아야하는 값인지를 검사해야 합니다.
location 과 일치한다면 찾아야하는 문서의 위치가 sorted 된 priorities의 인덱스 번째로 출력될 것입니다.

```js
if (currentValue[1] < priorities[count]) {
  const front = queue.dequeue();
  queue.enqueue(front);
} else {
  const printedValue = queue.dequeue();
  count++; //찾는 location 이 아니면 priorities 의 다음값을 가리킵니다.
  if (location === value[1]) {
    // 찾는 location 이라면 count 를 리턴해줍니다.
    return count;
  }
}
```

이렇게 location 을 정렬된 priorities 를 count 해주면서 찾아가는 것을 큐를 dequeue 하면서 반복해주면 됩니다.

### 최종 코드

```js
class Queue {
  constructor() {
    this.queue = [];

    this.front = 0;

    this.rear = 0;
  }

  enqueue(value) {
    this.queue[this.rear++] = value;
  }

  dequeue() {
    const value = this.queue[this.front];

    delete this.queue[this.front];

    this.front += 1;

    return value;
  }

  peek() {
    return this.queue[this.front];
  }

  size() {
    return this.rear - this.front;
  }
}

function solution(priorities, location) {
  let count = 0;

  const queue = new Queue();

  for (let i = 0; i < priorities.length; i++) {
    queue.enqueue([priorities[i], i]);
  }

  priorities.sort((a, b) => b - a);

  while (queue.size() > 0) {
    const currentValue = queue.peek();

    if (currentValue[0] < priorities[count]) {
      const front = queue.dequeue();

      queue.enqueue(front);
    } else {
      const value = queue.dequeue();

      count++;

      if (location === value[1]) {
        return count;
      }
    }
  }

  return count;
}

const priorities = [2, 1, 3, 4];

const location = 3;

console.log(solution(priorities, location));
```
