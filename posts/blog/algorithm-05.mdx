---
title: Algorithm - 피로도
date: 2022-08-01
description: 프로그래머스 알고리즘 문제
---

프로그래머스 level2. [[완전 탐색 / DFS]] 피로도

[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/87946)

### 문제 설명

XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다. "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- k는 1 이상 5,000 이하인 자연수입니다.
- dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
  - dungeons의 가로(열) 길이는 2 입니다.
  - dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
  - "최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다.
  - "최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다.
  - 서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.

### 입출력 예

```
k = 80

dungeons = [[80,20],[50,40],[30,10]]

result = 3
```

### 분류

- 완전 탐색

# 2. 풀이

유저가 탐험할 수있는 최대 던전의 수를 구해주어야 합니다.
탐험하면서 k 에서 `dungeons[i][1]` 를 빼가면서 `dungeons[i][0]` 보다 k 값이 큰 경우를 찾고 모든 조합 중 최대 값을 찾아줍니다.

방문해야 할 던전의 길이만큼 visited 를 만들어줍니다 [0,0,0]
만약, 최소 필요 피로도보다 값이 크고, 방문한 적이 없는 노드인 경우에는 (visited의값이 0인 경우 false가 됨) 해당 노드를 방문한 것으로 표시해줍니다. (visited[i]=1)

그리고 하위 노드가 있다면 dfs 가 재호출 되는데, 이때 `k-d[i][1]` 된 k 값을 인자로 넣어주고 count 도 +1 해줍니다. dfs 가 시작하는 하위의 노드는 다시 0으로 만들어줍니다.

추후 dfs가 재귀되면서 하위 노드가 있다면 1이 됩니다. 이렇게 구한 모든 조합 중 최대 값을 찾아서 리턴해주면 유저가 탐험할수 있는 최대 던전 수를 구할 수 있습니다.

```js
function solution(k, d) {
  const dLength = d.length; //방문해야 할 던전의 길이를 나타냅니다.
  const visited = new Array(dLength).fill(0); //방문한적이 있다면 1 값을 넣어줄 변수를 던전의 길이만큼 만들어줍니다.
  const answer = 0;
  let cnt = 0;

  //dfs 함수를 만들어서 던전의 길이만큼 재귀합니다.
  // dfs 의 인자로는 현재의 k 그리고 초기값으로 cnt(0)을 전달합니다.
  // 만약 k 에서 소모피로도를 뺀 값이 k 보다 큰 경우에 cnt 를 증가시켜 줄 것입니다.
  function dfs(k, cnt) {
    answer = Math.max(cnt, anwer);

    for (let i = 0; i < dLength; i++) {
      if (k > d[i][0] && !visited[i]) {
        //만약, 최소 필요 피로도보다 값이 크고, 방문한 적이 없는 노드인 경우에는 (visited의값이 0인 경우 false)
        visited[i] = 1; //해당 노드를 방문한 것으로 표시하고
        dfs(k - d[i][1], cnt + 1); // cnt값을 1 늘려 준 후 k 값에 소모 피로도를 빼 준 후 다음 노드를 탐색합니다. dfs
        visited[i] = 0; // 다음 노드를 탐색해야 하므로 다음 노드의 visitied는 다시 0으로 만들어줍니다. 즉 하위 노드가 있는 경우라면 계속 아래로 내려가며 부모의 노드 visitied 값을 1 로 만들면서 탐색합니다.
      }
    }

    return answer;
  }

  dfs(k, cnt);

  return answer;
}

const k = 80;

const dungeons = [
  [80, 20],

  [50, 40],

  [30, 10],
];

console.log(solution(k, dungeons));
```

# 3. 알게 된 점

dfs 에 대해서 학습 & 방문 노드 처리 방법
