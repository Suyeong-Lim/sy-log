---
title: Algorithm - 기능개발
date: 2022-07-17
description: 프로그래머스 알고리즘 문제
---

프로그래머스 level2. 스택 / 큐 기능개발

[기능 개발 문제링크](https://programmers.co.kr/learn/courses/30/lessons/42586)

### 문제 설명

프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

### 제한 사항

- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
- 작업 진도는 100 미만의 자연수입니다.
- 작업 속도는 100 이하의 자연수입니다.
- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

### 분류

- 스택 / 큐

# 2. 풀이

> 각각의 소요 시간을 map 으로 구해줍니다.
> progress(소요 시간)과 배포 우선순위 (maxPriority)를 비교합니다.

먼저, 주어진 progresses[] 와 speeds[] 를 보고 배포가능한 소요 시간 (날짜)를 구해주어야 합니다.

식을 세워보면 (100-progress)/speeds 를 하면 (100-93)/1 === 7 작업에 걸리는 날짜를 구할 수 있습니다. 제한 사항을 보면 올림값을 구해야 합니다. Math.ceil 을 통해 올림값으로 값을 구해줍니다.

이를 코드로 구현하면 다음과 같습니다.

```js
const progress = progresses.map((progress, i) =>
  Math.ceil((100 - progress) / speeds[i])
);
```

위의 코드로
배포에 필요한 날짜들의 배열값 `[7,3,9]` 를 구할 수 있습니다.

그 후에는 배포는 첫번째 값 부터 차례대로 배포 되어야 하기때문에 앞에 있는 값이 뒤에 있는 값보다 클 경우, 같을 경우에만 배포가 가능합니다.
크거나 같을 경우 뒤에 남은 progress들을 포함해서 배포할 수있기 때문에 answer에 누적해줍니다.

```js
let maxPriority = progress[0];

for (let i = 0; i < progress.length; i++) {
  if (progress[i] <= maxPriority) {
    answer[j] += 1;
  }
}
```

그러나 9 처럼 7보다 큰 값 즉, `(progress[i]>maxPriority)` 는 함께 배포할 수 없습니다.
이 경우 따로 배포 해주어야 하므로 maxPriority 의 값을 progress[i]로 초기화 한 후
answer의 사이즈를 늘리고 1로 값을 초기화 해줍니다.

```js
let maxPriority = progress[0];

for (let i = 0, j = 0; i < progress.length; i++) {
  if (progress[i] <= maxPriority) {
    answer[j] += 1;
  } else {
    maxPriority = progress[i];
    answer[++j] = 1;
  }
}
```

### 최종 코드

```js
function solution(progresses, speeds) {
  let answer = [0];

  const progress = progresses.map((v, i) => Math.ceil((100 - v) / speeds[i]));

  let maxPriority = progress[0];

  for (let i = 0, j = 0; i < progress.length; i++) {
    if (progress[i] <= maxPriority) {
      answer[j] += 1;
    } else {
      maxPriority = progress[i];

      answer[++j] = 1;
    }
  }

  return answer;
}

const progresses = [93, 30, 55];

const speeds = [1, 30, 5];

console.log(solution(progresses, speeds));
```

# 3. 알게 된 점

프로그래머스의 다른 코드를 참고했습니다.
for 문에 초기화를 두번한 코드는 처음인데 매우 유용하다고 생각했습니다.
